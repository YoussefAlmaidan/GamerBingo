<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck's Taskmaster - Real-Time Competition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
        }

        .header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ffd89b, #19547b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-status {
            text-align: center;
            flex-grow: 1;
            margin: 0 2rem;
        }

        .status-text {
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffd89b, #19547b);
            transition: width 0.3s ease;
            width: 0%;
        }

        .admin-gear {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.5rem;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
            z-index: 50;
        }

        .admin-gear:hover {
            transform: rotate(90deg);
        }

        .container {
            display: flex;
            min-height: calc(100vh - 80px);
            gap: 2rem;
            padding: 2rem;
        }

        .sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 1.5rem;
        }

        .card h3 {
            margin-bottom: 1rem;
            font-size: 1.2rem;
            color: #ffd89b;
        }

        .player-join {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .input-group {
            display: flex;
            gap: 0.5rem;
        }

        input, select, button {
            padding: 0.75rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            backdrop-filter: blur(10px);
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        button {
            background: linear-gradient(45deg, #ffd89b, #19547b);
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .player-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .leaderboard {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .leader-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid;
        }

        .main-board {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .task-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1rem;
            flex: 1;
        }

        .task-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-height: 160px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .task-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .task-card.completed {
            cursor: default;
            opacity: 0.8;
        }

        .task-card.completed::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1;
        }

        .task-card.completed .task-text {
            position: relative;
            z-index: 2;
        }

        .task-card.completed::after {
            content: '‚úì';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            z-index: 3;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .task-text {
            font-size: 0.95rem;
            line-height: 1.4;
            font-weight: 500;
        }

        .admin-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 2rem;
            z-index: 1000;
            display: none;
            flex-direction: column;
            gap: 1rem;
            min-width: 300px;
        }

        .admin-panel h3 {
            color: #ffd89b;
            margin-bottom: 1rem;
            text-align: center;
        }

        .admin-button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(20px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .game-over-content {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 3rem;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .winner-text {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #ffd89b, #19547b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .final-score {
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                flex-direction: row;
                overflow-x: auto;
            }
            
            .sidebar .card {
                min-width: 280px;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
                gap: 1rem;
            }
            
            .header {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
            }
            
            .game-status {
                margin: 0;
            }
            
            .sidebar {
                flex-direction: column;
            }
            
            .task-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .task-card {
                min-height: 120px;
                font-size: 0.85rem;
            }
        }

        @media (max-width: 480px) {
            .task-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }
            
            .task-card {
                min-height: 100px;
                padding: 0.75rem;
                font-size: 0.8rem;
            }
            
            .admin-panel {
                margin: 1rem;
                width: calc(100% - 2rem);
                min-width: unset;
            }
        }

        .editing-mode .task-card:not(.completed):hover {
            border-color: #ffd89b;
            box-shadow: 0 0 20px rgba(255, 216, 155, 0.3);
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">ü¶Ü Duck's Taskmaster</div>
        <div class="game-status">
            <div class="status-text" id="statusText">Waiting for players...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        <div id="currentPlayer" style="font-weight: bold; color: #ffd89b;"></div>
    </header>

    <div class="container">
        <aside class="sidebar">
            <div class="card">
                <h3>Join Game</h3>
                <div class="player-join">
                    <div class="input-group">
                        <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                        <button id="joinButton">Join</button>
                    </div>
                    <select id="playerSelect" class="hidden">
                        <option value="">Select yourself</option>
                    </select>
                </div>
            </div>

            <div class="card">
                <h3>Players</h3>
                <div class="player-list" id="playerList"></div>
            </div>

            <div class="card">
                <h3>Leaderboard</h3>
                <div class="leaderboard" id="leaderboard"></div>
            </div>
        </aside>

        <main class="main-board">
            <div class="task-grid" id="taskGrid"></div>
        </main>
    </div>

    <div class="admin-gear" id="adminGear">‚öôÔ∏è</div>

    <div class="admin-panel" id="adminPanel">
        <h3>üõ†Ô∏è Admin Panel</h3>
        <button class="admin-button" id="resetGame">Reset Entire Game</button>
        <button class="admin-button" id="clearTasks">Clear All Tasks</button>
        <button class="admin-button" id="removeLastPlayer">Remove Last Player</button>
        <button class="admin-button" id="toggleEditMode">Toggle Task Editing</button>
        <button id="closeAdmin">Close Panel</button>
    </div>

    <div class="game-over" id="gameOver">
        <div class="game-over-content">
            <div class="winner-text" id="winnerText">üéâ Game Complete! üéâ</div>
            <div class="final-score" id="finalScore"></div>
            <button id="newGameButton">Start New Game</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, push, remove, update } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-database.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBMS5W47Xjn5G0mO2Me5xIKalLzv-ukLZA",
            authDomain: "gamerbingo-fc745.firebaseapp.com",
            databaseURL: "https://gamerbingo-fc745-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "gamerbingo-fc745",
            storageBucket: "gamerbingo-fc745.firebasestorage.app",
            messagingSenderId: "864050565555",  
            appId: "1:864050565555:web:133ceb64c6f116b5cabbc6"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Game state
        let currentPlayerId = null;
        let editMode = false;
        let gameData = {
            players: {},
            tasks: {},
            gameState: 'waiting'
        };

        // Predefined tasks
        const defaultTasks = [
            "Get a team kill", "Win a round without dying", "Clutch a 1v3 situation",
            "Get a headshot", "Use a unique weapon", "Complete without taking damage",
            "Finish in under 2 minutes", "Get the highest score", "Help a teammate",
            "Use only melee attacks", "Win with less than 10% health", "Get a double kill",
            "Complete a bonus objective", "Survive for 5+ minutes", "Get first place",
            "Use a special ability", "Collect all items", "Defeat the boss",
            "Complete without using items", "Get a killstreak of 5+", "Win by teamwork",
            "Complete a secret area", "Achieve perfect accuracy", "Complete speedrun challenge",
            "Get the final kill"
        ];

        // Color palette for players
        const playerColors = [
            '#ff9f9b', '#ffb347', '#77dd77', '#87ceeb', '#dda0dd',
            '#f0e68c', '#ffa07a', '#98fb98', '#87cefa', '#dbb2ff',
            '#ffcccb', '#ffd700', '#90ee90', '#add8e6', '#plum'
        ];

        // Initialize game
        function initializeGame() {
            initializeTasks();
            setupEventListeners();
            setupFirebaseListeners();
            updateUI();
        }

        // Initialize tasks in Firebase if they don't exist
        async function initializeTasks() {
            const tasksRef = ref(database, 'tasks');
            const snapshot = await get(tasksRef);
            
            if (!snapshot.exists()) {
                const tasks = {};
                defaultTasks.forEach((task, index) => {
                    tasks[index] = {
                        text: task,
                        completed: false,
                        completedBy: null,
                        completedAt: null
                    };
                });
                await set(tasksRef, tasks);
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            document.getElementById('joinButton').addEventListener('click', joinGame);
            document.getElementById('playerName').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinGame();
            });
            document.getElementById('playerSelect').addEventListener('change', selectPlayer);
            
            // Admin panel
            let gearClickCount = 0;
            let gearClickTimer = null;
            
            document.getElementById('adminGear').addEventListener('click', () => {
                gearClickCount++;
                if (gearClickCount === 1) {
                    gearClickTimer = setTimeout(() => {
                        gearClickCount = 0;
                    }, 1000);
                } else if (gearClickCount === 3) {
                    clearTimeout(gearClickTimer);
                    gearClickCount = 0;
                    document.getElementById('adminPanel').style.display = 'flex';
                }
            });

            document.getElementById('closeAdmin').addEventListener('click', () => {
                document.getElementById('adminPanel').style.display = 'none';
            });

            document.getElementById('resetGame').addEventListener('click', resetGame);
            document.getElementById('clearTasks').addEventListener('click', clearTasks);
            document.getElementById('removeLastPlayer').addEventListener('click', removeLastPlayer);
            document.getElementById('toggleEditMode').addEventListener('click', toggleEditMode);
            document.getElementById('newGameButton').addEventListener('click', resetGame);

            // Close admin panel when clicking outside
            document.addEventListener('click', (e) => {
                const adminPanel = document.getElementById('adminPanel');
                const adminGear = document.getElementById('adminGear');
                if (!adminPanel.contains(e.target) && !adminGear.contains(e.target)) {
                    adminPanel.style.display = 'none';
                }
            });
        }

        // Setup Firebase listeners
        function setupFirebaseListeners() {
            // Listen to players
            onValue(ref(database, 'players'), (snapshot) => {
                gameData.players = snapshot.val() || {};
                updatePlayerList();
                updatePlayerSelect();
                updateLeaderboard();
                updateCurrentPlayerDisplay();
            });

            // Listen to tasks
            onValue(ref(database, 'tasks'), (snapshot) => {
                gameData.tasks = snapshot.val() || {};
                updateTaskGrid();
                updateGameStatus();
                checkGameEnd();
            });
        }

        // Join game
        async function joinGame() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput.value.trim();
            
            if (!name) return;

            // Check if name already exists
            const playersSnapshot = await get(ref(database, 'players'));
            const existingPlayers = playersSnapshot.val() || {};
            
            if (Object.values(existingPlayers).some(player => player.name === name)) {
                alert('Name already taken! Choose another name.');
                return;
            }

            // Create new player
            const playersRef = ref(database, 'players');
            const newPlayerRef = push(playersRef);
            const playerId = newPlayerRef.key;
            
            const usedColors = Object.values(existingPlayers).map(p => p.color);
            const availableColors = playerColors.filter(color => !usedColors.includes(color));
            const playerColor = availableColors[0] || playerColors[Math.floor(Math.random() * playerColors.length)];

            await set(newPlayerRef, {
                name: name,
                color: playerColor,
                score: 0,
                joinedAt: Date.now()
            });

            nameInput.value = '';
            document.getElementById('joinButton').style.display = 'none';
            nameInput.style.display = 'none';
            document.getElementById('playerSelect').classList.remove('hidden');
        }

        // Select current player
        function selectPlayer() {
            const select = document.getElementById('playerSelect');
            currentPlayerId = select.value;
            updateCurrentPlayerDisplay();
        }

        // Update player list
        function updatePlayerList() {
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = '';

            Object.entries(gameData.players).forEach(([id, player]) => {
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                playerItem.innerHTML = `
                    <div class="player-color" style="background-color: ${player.color}"></div>
                    <span>${player.name}</span>
                `;
                playerList.appendChild(playerItem);
            });
        }

        // Update player select dropdown
        function updatePlayerSelect() {
            const select = document.getElementById('playerSelect');
            const currentValue = select.value;
            
            select.innerHTML = '<option value="">Select yourself</option>';
            
            Object.entries(gameData.players).forEach(([id, player]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = player.name;
                if (id === currentValue) option.selected = true;
                select.appendChild(option);
            });
        }

        // Update current player display
        function updateCurrentPlayerDisplay() {
            const display = document.getElementById('currentPlayer');
            if (currentPlayerId && gameData.players[currentPlayerId]) {
                const player = gameData.players[currentPlayerId];
                display.textContent = `Playing as: ${player.name}`;
                display.style.color = player.color;
            } else {
                display.textContent = '';
            }
        }

        // Update leaderboard
        function updateLeaderboard() {
            const leaderboard = document.getElementById('leaderboard');
            leaderboard.innerHTML = '';

            const sortedPlayers = Object.entries(gameData.players)
                .sort(([,a], [,b]) => b.score - a.score);

            sortedPlayers.forEach(([id, player], index) => {
                const leaderItem = document.createElement('div');
                leaderItem.className = 'leader-item';
                leaderItem.style.borderLeftColor = player.color;
                
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                
                leaderItem.innerHTML = `
                    <span>${medal} ${player.name}</span>
                    <span>${player.score} tasks</span>
                `;
                leaderboard.appendChild(leaderItem);
            });
        }

        // Update task grid
        function updateTaskGrid() {
            const taskGrid = document.getElementById('taskGrid');
            taskGrid.innerHTML = '';
            
            if (editMode) {
                taskGrid.classList.add('editing-mode');
            } else {
                taskGrid.classList.remove('editing-mode');
            }

            Object.entries(gameData.tasks).forEach(([id, task]) => {
                const taskCard = document.createElement('div');
                taskCard.className = 'task-card';
                taskCard.dataset.taskId = id;
                
                if (task.completed) {
                    taskCard.classList.add('completed');
                    taskCard.style.backgroundColor = task.completedBy && gameData.players[task.completedBy] 
                        ? gameData.players[task.completedBy].color + '40'
                        : 'rgba(255, 255, 255, 0.1)';
                }

                taskCard.innerHTML = `<div class="task-text">${task.text}</div>`;

                // Task completion
                taskCard.addEventListener('click', () => {
                    if (!task.completed && currentPlayerId) {
                        completeTask(id);
                    }
                });

                // Right-click to cancel (admin)
                taskCard.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (task.completed) {
                        cancelTask(id);
                    }
                });

                // Double-click to edit (admin, edit mode)
                taskCard.addEventListener('dblclick', () => {
                    if (editMode && !task.completed) {
                        editTask(id, task.text);
                    }
                });

                taskGrid.appendChild(taskCard);
            });
        }

        // Complete task
        async function completeTask(taskId) {
            if (!currentPlayerId) {
                alert('Please select yourself from the dropdown first!');
                return;
            }

            const taskRef = ref(database, `tasks/${taskId}`);
            const playerRef = ref(database, `players/${currentPlayerId}`);
            
            await update(taskRef, {
                completed: true,
                completedBy: currentPlayerId,
                completedAt: Date.now()
            });

            const currentPlayer = gameData.players[currentPlayerId];
            await update(playerRef, {
                score: (currentPlayer.score || 0) + 1
            });
        }

        // Cancel task (admin)
        async function cancelTask(taskId) {
            const task = gameData.tasks[taskId];
            if (!task.completed) return;

            const taskRef = ref(database, `tasks/${taskId}`);
            const playerRef = ref(database, `players/${task.completedBy}`);
            
            await update(taskRef, {
                completed: false,
                completedBy: null,
                completedAt: null
            });

            if (task.completedBy && gameData.players[task.completedBy]) {
                const player = gameData.players[task.completedBy];
                await update(playerRef, {
                    score: Math.max(0, (player.score || 0) - 1)
                });
            }
        }

        // Edit task (admin)
        function editTask(taskId, currentText) {
            const newText = prompt('Edit task:', currentText);
            if (newText && newText.trim()) {
                update(ref(database, `tasks/${taskId}`), {
                    text: newText.trim()
                });
            }
        }

        // Update game status
        function updateGameStatus() {
            const completedTasks = Object.values(gameData.tasks).filter(task => task.completed).length;
            const totalTasks = Object.keys(gameData.tasks).length;
            const progress = totalTasks > 0 ? (completedTasks / totalTasks * 100) : 0;

            document.getElementById('statusText').textContent = 
                `${completedTasks}/${totalTasks} tasks completed`;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        // Check game end
        function checkGameEnd() {
            const completedTasks = Object.values(gameData.tasks).filter(task => task.completed).length;
            const totalTasks = Object.keys(gameData.tasks).length;

            if (completedTasks === totalTasks && totalTasks > 0) {
                showGameOver();
            }
        }

        // Show game over
        function showGameOver() {
            const sortedPlayers = Object.entries(gameData.players)
                .sort(([,a], [,b]) => b.score - a.score);

            if (sortedPlayers.length > 0) {
                const winner = sortedPlayers[0][1];
                document.getElementById('winnerText').textContent = `üéâ ${winner.name} Wins! üéâ`;
                document.getElementById('winnerText').style.color = winner.color;
                
                let scoreText = `Final Score: ${winner.score} tasks\n\nFull Results:\n`;
                sortedPlayers.forEach(([, player], index) => {
                    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                    scoreText += `${medal} ${player.name}: ${player.score} tasks\n`;
                });
                
                document.getElementById('finalScore').textContent = scoreText;
            }

            document.getElementById('gameOver').style.display = 'flex';
        }

        // Admin functions
        async function resetGame() {
            if (confirm('Reset entire game? This will remove all players and tasks.')) {
                await set(ref(database, 'players'), {});
                await set(ref(database, 'tasks'), {});
                await initializeTasks();
                
                currentPlayerId = null;
                document.getElementById('playerSelect').classList.add('hidden');
                document.getElementById('joinButton').style.display = 'inline-block';
                document.getElementById('playerName').style.display = 'inline-block';
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('adminPanel').style.display = 'none';
                updateCurrentPlayerDisplay();
            }
        }

        async function clearTasks() {
            if (confirm('Clear all completed tasks? Players will keep their accounts.')) {
                const updates = {};
                Object.keys(gameData.tasks).forEach(taskId => {
                    updates[`tasks/${taskId}/completed`] = false;
                    updates[`tasks/${taskId}/completedBy`] = null;
                    updates[`tasks/${taskId}/completedAt`] = null;
                });
                
                Object.keys(gameData.players).forEach(playerId => {
                    updates[`players/${playerId}/score`] = 0;
                });
                
                await update(ref(database), updates);
                document.getElementById('gameOver').style.display = 'none';
            }
        }

        async function removeLastPlayer() {
            const sortedPlayers = Object.entries(gameData.players)
                .sort(([,a], [,b]) => b.joinedAt - a.joinedAt);
            
            if (sortedPlayers.length === 0) return;
            
            const [lastPlayerId, lastPlayer] = sortedPlayers[0];
            
            if (confirm(`Remove ${lastPlayer.name} and their completed tasks?`)) {
                // Remove tasks completed by this player
                const updates = {};
                Object.entries(gameData.tasks).forEach(([taskId, task]) => {
                    if (task.completedBy === lastPlayerId) {
                        updates[`tasks/${taskId}/completed`] = false;
                        updates[`tasks/${taskId}/completedBy`] = null;
                        updates[`tasks/${taskId}/completedAt`] = null;
                    }
                });
                
                await update(ref(database), updates);
                await remove(ref(database, `players/${lastPlayerId}`));
                
                if (currentPlayerId === lastPlayerId) {
                    currentPlayerId = null;
                    document.getElementById('playerSelect').classList.add('hidden');
                    document.getElementById('joinButton').style.display = 'inline-block';
                    document.getElementById('playerName').style.display = 'inline-block';
                    updateCurrentPlayerDisplay();
                }
            }
        }

        function toggleEditMode() {
            editMode = !editMode;
            updateTaskGrid();
            
            const button = document.getElementById('toggleEditMode');
            button.textContent = editMode ? 'Exit Edit Mode' : 'Toggle Task Editing';
            button.style.background = editMode 
                ? 'linear-gradient(45deg, #4ecdc4, #44a08d)' 
                : 'linear-gradient(45deg, #ff6b6b, #ee5a24)';
        }

        // Update UI
        function updateUI() {
            updatePlayerList();
            updatePlayerSelect();
            updateLeaderboard();
            updateTaskGrid();
            updateGameStatus();
            updateCurrentPlayerDisplay();
        }

        // Initialize when page loads
        initializeGame();
    </script>
</body>
</html>
