<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck's Taskmaster - Real-Time Multiplayer Game</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>

    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <span id="toastMessage"></span>
    </div>

    <!-- Header -->
    <header class="header">
        <h1>ü¶Ü Duck's Taskmaster</h1>
        <div class="game-status">
            <div class="status-badge">
                <span id="completedCount">0</span> / 25 tasks completed
            </div>
            <div class="status-badge edit-mode-badge" id="editModeIndicator" style="display: none;">
                üìù Edit Mode Active
            </div>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Player Section -->
            <div class="sidebar-section">
                <h2>üéÆ Join Game</h2>
                <div class="player-join">
                    <input type="text" id="playerName" placeholder="Enter your name" maxlength="20" autocomplete="off">
                    <button class="btn" onclick="joinGame()" id="joinBtn">Join</button>
                </div>
                <select id="playerSelect" class="player-select">
                    <option value="">Select yourself</option>
                </select>
                <div class="current-player" id="currentPlayer">
                    No player selected
                </div>
            </div>

            <!-- Leaderboard Section -->
            <div class="sidebar-section">
                <h2>üèÜ Leaderboard</h2>
                <div class="leaderboard" id="leaderboard">
                    <div style="text-align: center; color: #a0aec0; padding: 2rem;">
                        No players yet
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Board -->
        <main class="main-board">
            <div class="task-grid" id="taskGrid">
                <!-- Task cards will be dynamically generated -->
            </div>
        </main>
    </div>

    <!-- Admin Toggle -->
    <div class="admin-toggle" id="adminToggle" title="Admin Panel (Triple-click)">
        <svg viewBox="0 0 24 24">
            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5a3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97c0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1c0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66Z"/>
        </svg>
    </div>

    <!-- Admin Panel -->
    <div class="admin-panel" id="adminPanel">
        <h3>‚öôÔ∏è Admin Controls</h3>
        <div class="admin-controls">
            <button class="btn btn-danger" onclick="resetGame()">üîÑ Reset Entire Game</button>
            <button class="btn btn-danger" onclick="clearTasks()">üßπ Clear All Tasks</button>
            <button class="btn btn-danger" onclick="removeLastPlayer()">üë§ Remove Last Player</button>
            <button class="btn btn-success" onclick="toggleEditMode()">‚úèÔ∏è Toggle Edit Mode</button>
        </div>
        <div class="admin-status" id="adminStatus">
            Edit mode: <span id="editModeStatus">OFF</span>
        </div>
    </div>

    <!-- Password Modal -->
    <div class="modal" id="passwordModal">
        <div class="modal-content">
            <h3>üîí Enter Admin Password</h3>
            <input type="password" id="passwordInput" class="modal-input" placeholder="Password" autocomplete="off">
            <div class="modal-buttons">
                <button class="btn" style="background: #a0aec0;" onclick="cancelPassword()">Cancel</button>
                <button class="btn btn-success" onclick="checkPassword()">Unlock</button>
            </div>
            <div class="modal-error" id="passwordError">
                ‚ùå Incorrect password. Try again.
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, push, remove } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-database.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBMS5W47Xjn5G0mO2Me5xIKalLzv-ukLZA",
            authDomain: "gamerbingo-fc745.firebaseapp.com",
            databaseURL: "https://gamerbingo-fc745-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "gamerbingo-fc745",
            storageBucket: "gamerbingo-fc745.firebasestorage.app",
            messagingSenderId: "864050565555",
            appId: "1:864050565555:web:133ceb64c6f116b5cabbc6"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);

        // Game state
        let currentPlayerId = null;
        let editMode = false;
        let adminClickCount = 0;
        let adminClickTimer = null;
        let gameData = {
            players: {},
            tasks: {}
        };

        // Constants
        const ADMIN_PASSWORD = 'fishsticks';
        const playerColors = [
            '#E6194B', '#3CB44B', '#0082C8', '#F58231', '#911EB4',
            '#46F0F0', '#F032E6', '#D2F53C', '#FABEBE', '#008080',
            '#AA6E28', '#FFA07A', '#FFD700', '#DC143C', '#20B2AA'
        ];

        const defaultTasks = [
            "Eat pasta", "Win a 1v1", "Explode a car", "Pet a dog", "Get 1st place or MVP",
            "Win a run (not a literal run)", "Build a Masjid", "Make someone laugh", "Dress in a full purple outfit", "Beat a boss",
            "Get 10k currency", "Find a Legendary item", "Take a screenshot with 10 zombies in the frame", "Level up", "Kill a friendly NPC",
            "Solve a puzzle", "Find a real life brand", "Kill something while you are dead", "Take a screenshot of a duck", "Perform a 10 hit combo",
            "Get 8 headshots in a row", "Crash the game", "Plant and harvest 3 different plants", "In a character creator, make Dio Brando", "Heal exactly 50HP in one burst"
        ];

        // Utility functions
        function showLoading() {
            document.getElementById('loadingOverlay').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('show');
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            const toastMessage = document.getElementById('toastMessage');
            
            toast.className = `toast ${type}`;
            toastMessage.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // Initialize game
        function initializeGame() {
            showLoading();
            
            const playersRef = ref(database, 'players');
            const tasksRef = ref(database, 'tasks');

            onValue(playersRef, (snapshot) => {
                gameData.players = snapshot.val() || {};
                updatePlayerSelect();
                updateLeaderboard();
                hideLoading();
            });

            onValue(tasksRef, (snapshot) => {
                const data = snapshot.val();
                if (!data || Object.keys(data).length === 0) {
                    initializeTasks();
                } else {
                    gameData.tasks = data;
                    updateTaskGrid();
                    updateGameStatus();
                }
                hideLoading();
            });
        }

        // Initialize tasks
        async function initializeTasks() {
            const tasksRef = ref(database, 'tasks');
            const tasks = {};
            
            defaultTasks.forEach((taskName, index) => {
                tasks[`task${index}`] = {
                    name: taskName,
                    completed: false,
                    completedBy: null
                };
            });
            
            try {
                await set(tasksRef, tasks);
                showToast('Game initialized successfully!');
            } catch (error) {
                console.error('Error initializing tasks:', error);
                showToast('Failed to initialize game', 'error');
            }
        }

        // Join game
        window.joinGame = async function() {
            const nameInput = document.getElementById('playerName');
            const joinBtn = document.getElementById('joinBtn');
            const name = nameInput.value.trim();
            
            if (!name) {
                showToast('Please enter your name', 'warning');
                nameInput.focus();
                return;
            }

            if (name.length > 20) {
                showToast('Name too long (max 20 characters)', 'warning');
                return;
            }

            // Check if name already exists
            const existingPlayer = Object.values(gameData.players).find(p => 
                p.name.toLowerCase() === name.toLowerCase()
            );
            if (existingPlayer) {
                showToast('This name is already taken!', 'warning');
                nameInput.focus();
                nameInput.select();
                return;
            }

            joinBtn.disabled = true;
            joinBtn.textContent = 'Joining...';

            try {
                const playersRef = ref(database, 'players');
                const newPlayerRef = push(playersRef);
                const colorIndex = Object.keys(gameData.players).length % playerColors.length;
                
                await set(newPlayerRef, {
                    name: name,
                    color: playerColors[colorIndex],
                    score: 0
                });

                nameInput.value = '';
                showToast(`Welcome, ${name}! üéâ`);
                
                // Auto-select the new player
                setTimeout(() => {
                    const playerSelect = document.getElementById('playerSelect');
                    playerSelect.value = newPlayerRef.key;
                    currentPlayerId = newPlayerRef.key;
                    updateCurrentPlayer();
                }, 500);
                
            } catch (error) {
                console.error('Error joining game:', error);
                showToast('Failed to join game. Please try again.', 'error');
            } finally {
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join';
            }
        };

        // Update player select
        function updatePlayerSelect() {
            const select = document.getElementById('playerSelect');
            const currentValue = select.value;
            
            select.innerHTML = '<option value="">Select yourself</option>';
            
            Object.entries(gameData.players).forEach(([id, player]) => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = player.name;
                select.appendChild(option);
            });

            if (currentValue && gameData.players[currentValue]) {
                select.value = currentValue;
                currentPlayerId = currentValue;
                updateCurrentPlayer();
            }
        }

        // Player select handler
        document.getElementById('playerSelect').addEventListener('change', function(e) {
            currentPlayerId = e.target.value;
            updateCurrentPlayer();
            if (currentPlayerId) {
                showToast(`Playing as ${gameData.players[currentPlayerId].name}! üéÆ`);
            }
        });

        // Update current player display
        function updateCurrentPlayer() {
            const display = document.getElementById('currentPlayer');
            if (currentPlayerId && gameData.players[currentPlayerId]) {
                const player = gameData.players[currentPlayerId];
                display.textContent = `Playing as: ${player.name}`;
                display.classList.add('active');
                display.style.borderColor = player.color;
            } else {
                display.textContent = 'No player selected';
                display.classList.remove('active');
                display.style.borderColor = '#e2e8f0';
            }
        }

        // Update leaderboard
        function updateLeaderboard() {
            const leaderboard = document.getElementById('leaderboard');
            
            if (Object.keys(gameData.players).length === 0) {
                leaderboard.innerHTML = `
                    <div style="text-align: center; color: #a0aec0; padding: 2rem;">
                        No players yet
                    </div>
                `;
                return;
            }

            leaderboard.innerHTML = '';
            
            const sortedPlayers = Object.entries(gameData.players)
                .sort(([,a], [,b]) => b.score - a.score);

            sortedPlayers.forEach(([id, player], index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';
                
                // Highlight winner if game is complete
                const completedTasks = Object.values(gameData.tasks).filter(t => t.completed).length;
                if (index === 0 && completedTasks === 25 && Object.keys(gameData.tasks).length === 25 && player.score > 0) {
                    item.classList.add('winner');
                }
                
                item.innerHTML = `
                    <div class="leaderboard-name">
                        <div class="player-dot" style="background-color: ${player.color}"></div>
                        <span>${player.name}</span>
                        ${index === 0 && player.score > 0 ? 'üëë' : ''}
                    </div>
                    <div class="leaderboard-score">${player.score}</div>
                `;
                leaderboard.appendChild(item);
            });
        }

        // Update task grid
        function updateTaskGrid() {
            const grid = document.getElementById('taskGrid');
            grid.innerHTML = '';

            Object.entries(gameData.tasks).forEach(([taskId, task]) => {
                const card = document.createElement('div');
                card.className = 'task-card';
                card.dataset.taskId = taskId;
                card.tabIndex = 0; // Make focusable for keyboard navigation
                
                const taskText = document.createElement('span');
                taskText.textContent = task.name;
                card.appendChild(taskText);
                
                if (task.completed && task.completedBy && gameData.players[task.completedBy]) {
                    card.classList.add('completed');
                    card.style.color = gameData.players[task.completedBy].color;
                    card.title = `Completed by ${gameData.players[task.completedBy].name}`;
                }
                
                // Event listeners
                card.addEventListener('click', () => handleTaskClick(taskId));
                card.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleTaskClick(taskId);
                    }
                });
                
                if (editMode) {
                    card.classList.add('editing');
                    card.addEventListener('dblclick', () => editTask(taskId));
                    card.title = editMode ? 'Double-click to edit' : '';
                }
                
                if (task.completed) {
                    card.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        if (confirm(`Cancel "${task.name}"? This will reset the task and reduce the player's score.`)) {
                            cancelTask(taskId);
                        }
                    });
                }
                
                grid.appendChild(card);
            });
        }

        // Handle task click
        async function handleTaskClick(taskId) {
            if (editMode) return;
            
            if (!currentPlayerId) {
                showToast('Please select yourself first! üëÜ', 'warning');
                document.getElementById('playerSelect').focus();
                return;
            }

            const task = gameData.tasks[taskId];
            if (!task) return;
            
            if (task.completed) {
                showToast('Task already completed! üéØ', 'warning');
                return;
            }

            showLoading();

            try {
                // Complete the task
                const taskRef = ref(database, `tasks/${taskId}`);
                await set(taskRef, {
                    name: task.name,
                    completed: true,
                    completedBy: currentPlayerId
                });

                // Update player score
                const playerRef = ref(database, `players/${currentPlayerId}`);
                const currentScore = gameData.players[currentPlayerId].score || 0;
                await set(playerRef, {
                    ...gameData.players[currentPlayerId],
                    score: currentScore + 1
                });

                showToast(`Great job! Task completed! üéâ`);
                
            } catch (error) {
                console.error('Error completing task:', error);
                showToast('Failed to complete task. Please try again.', 'error');
            } finally {
                hideLoading();
            }
        }

        // Edit task
        function editTask(taskId) {
            if (!editMode) return;
            
            const task = gameData.tasks[taskId];
            if (!task) return;
            
            const newName = prompt('Edit task name:', task.name);
            
            if (newName && newName.trim() && newName.trim() !== task.name) {
                showLoading();
                
                const taskRef = ref(database, `tasks/${taskId}`);
                const updatedTask = {
                    name: newName.trim(),
                    completed: task.completed || false,
                    completedBy: task.completedBy || null
                };
                
                set(taskRef, updatedTask).then(() => {
                    showToast('Task updated successfully! ‚úèÔ∏è');
                    hideLoading();
                }).catch((error) => {
                    console.error('Error updating task:', error);
                    showToast('Failed to update task. Please try again.', 'error');
                    hideLoading();
                });
            }
        }

        // Cancel task
        async function cancelTask(taskId) {
            const task = gameData.tasks[taskId];
            if (!task || !task.completed) return;

            showLoading();

            try {
                // Update task
                const taskRef = ref(database, `tasks/${taskId}`);
                await set(taskRef, {
                    name: task.name,
                    completed: false,
                    completedBy: null
                });

                // Update player score
                if (task.completedBy && gameData.players[task.completedBy]) {
                    const playerRef = ref(database, `players/${task.completedBy}`);
                    const currentScore = gameData.players[task.completedBy].score || 0;
                    await set(playerRef, {
                        ...gameData.players[task.completedBy],
                        score: Math.max(0, currentScore - 1)
                    });
                }

                showToast('Task cancelled and score updated! ‚Ü©Ô∏è');
                
            } catch (error) {
                console.error('Error canceling task:', error);
                showToast('Failed to cancel task. Please try again.', 'error');
            } finally {
                hideLoading();
            }
        }

        // Update game status
        function updateGameStatus() {
            const completedCount = Object.values(gameData.tasks).filter(t => t.completed).length;
            document.getElementById('completedCount').textContent = completedCount;

            // Check if game is complete
            if (completedCount === 25 && Object.keys(gameData.tasks).length === 25) {
                const winner = Object.entries(gameData.players)
                    .sort(([,a], [,b]) => b.score - a.score)[0];
                
                if (winner && winner[1].score > 0) {
                    setTimeout(() => {
                        showToast(`üéâ GAME OVER! Winner: ${winner[1].name} with ${winner[1].score} tasks! üèÜ`, 'success');
                    }, 1000);
                }
            }
        }

        // Admin panel functionality
        document.getElementById('adminToggle').addEventListener('click', function(e) {
            adminClickCount++;
            
            if (adminClickTimer) {
                clearTimeout(adminClickTimer);
            }
            
            adminClickTimer = setTimeout(() => {
                adminClickCount = 0;
            }, 1000);
            
            if (adminClickCount === 3) {
                showPasswordModal();
                adminClickCount = 0;
            }
        });

        function showPasswordModal() {
            document.getElementById('passwordModal').classList.add('show');
            document.getElementById('passwordInput').focus();
            document.getElementById('passwordError').style.display = 'none';
        }

        window.cancelPassword = function() {
            document.getElementById('passwordModal').classList.remove('show');
            document.getElementById('passwordInput').value = '';
        };

        window.checkPassword = function() {
            const password = document.getElementById('passwordInput').value;
            
            if (password === ADMIN_PASSWORD) {
                document.getElementById('adminPanel').classList.toggle('show');
                cancelPassword();
                showToast('Admin panel unlocked! üîì', 'success');
            } else {
                document.getElementById('passwordError').style.display = 'block';
                document.getElementById('passwordInput').value = '';
                document.getElementById('passwordInput').focus();
                setTimeout(() => {
                    document.getElementById('passwordError').style.display = 'none';
                }, 3000);
            }
        };

        // Keyboard shortcuts
        document.getElementById('passwordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                checkPassword();
            }
        });

        document.getElementById('playerName').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                joinGame();
            }
        });

        // Admin functions
        window.resetGame = async function() {
            if (!confirm('‚ö†Ô∏è Reset the entire game?\n\nThis will:\n‚Ä¢ Remove all players\n‚Ä¢ Reset all tasks\n‚Ä¢ Clear all scores\n\nThis cannot be undone!')) {
                return;
            }

            showLoading();
            
            try {
                await set(ref(database, 'players'), {});
                await set(ref(database, 'tasks'), {});
                await initializeTasks();
                currentPlayerId = null;
                updateCurrentPlayer();
                showToast('Game reset successfully! üîÑ');
            } catch (error) {
                console.error('Error resetting game:', error);
                showToast('Failed to reset game. Please try again.', 'error');
            } finally {
                hideLoading();
            }
        };

        window.clearTasks = async function() {
            if (!confirm('üßπ Clear all completed tasks?\n\nPlayers will keep their current scores, but all tasks will be reset to incomplete.')) {
                return;
            }

            showLoading();
            
            try {
                const clearedTasks = {};
                Object.entries(gameData.tasks).forEach(([id, task]) => {
                    clearedTasks[id] = {
                        name: task.name,
                        completed: false,
                        completedBy: null
                    };
                });
                await set(ref(database, 'tasks'), clearedTasks);
                showToast('All tasks cleared! üßπ');
            } catch (error) {
                console.error('Error clearing tasks:', error);
                showToast('Failed to clear tasks. Please try again.', 'error');
            } finally {
                hideLoading();
            }
        };

        window.removeLastPlayer = async function() {
            const playerIds = Object.keys(gameData.players);
            if (playerIds.length === 0) {
                showToast('No players to remove', 'warning');
                return;
            }

            const lastPlayerId = playerIds[playerIds.length - 1];
            const lastPlayer = gameData.players[lastPlayerId];
            
            if (!confirm(`üë§ Remove player "${lastPlayer.name}"?\n\nThis will:\n‚Ä¢ Remove the player from the game\n‚Ä¢ Reset all tasks they completed\n‚Ä¢ Cannot be undone`)) {
                return;
            }

            showLoading();
            
            try {
                // Remove player
                await remove(ref(database, `players/${lastPlayerId}`));
                
                // Reset their tasks
                const updatedTasks = {};
                Object.entries(gameData.tasks).forEach(([id, task]) => {
                    if (task.completedBy === lastPlayerId) {
                        updatedTasks[id] = {
                            name: task.name,
                            completed: false,
                            completedBy: null
                        };
                    } else {
                        updatedTasks[id] = {
                            name: task.name,
                            completed: task.completed || false,
                            completedBy: task.completedBy || null
                        };
                    }
                });
                await set(ref(database, 'tasks'), updatedTasks);
                
                // Clear current player if removed
                if (currentPlayerId === lastPlayerId) {
                    currentPlayerId = null;
                    updateCurrentPlayer();
                }
                
                showToast(`Player "${lastPlayer.name}" removed! üëã`);
                
            } catch (error) {
                console.error('Error removing player:', error);
                showToast('Failed to remove player. Please try again.', 'error');
            } finally {
                hideLoading();
            }
        };

        window.toggleEditMode = function() {
            editMode = !editMode;
            document.getElementById('editModeStatus').textContent = editMode ? 'ON' : 'OFF';
            document.getElementById('editModeIndicator').style.display = editMode ? 'inline-block' : 'none';
            
            const adminStatus = document.getElementById('adminStatus');
            if (editMode) {
                adminStatus.classList.add('active');
                adminStatus.innerHTML = '‚ö†Ô∏è Edit mode: <span id="editModeStatus">ON</span><br><small>Double-click tasks to edit names.<br>Task completion is disabled.</small>';
                showToast('Edit mode activated! Double-click tasks to edit. ‚úèÔ∏è', 'warning');
            } else {
                adminStatus.classList.remove('active');
                adminStatus.innerHTML = 'Edit mode: <span id="editModeStatus">OFF</span>';
                showToast('Edit mode deactivated! Normal gameplay resumed. üéÆ');
            }
            updateTaskGrid();
        };

        // Click outside to close admin panel
        document.addEventListener('click', function(e) {
            const adminPanel = document.getElementById('adminPanel');
            const adminToggle = document.getElementById('adminToggle');
            
            if (!adminPanel.contains(e.target) && !adminToggle.contains(e.target)) {
                adminPanel.classList.remove('show');
            }
        });

        // Initialize the game
        initializeGame();
    </script>
</body>
</html>
